# transition_matrix_plotly_dashboard.py
# Python 3.9

from __future__ import annotations
import re
from pathlib import Path
from typing import List, Tuple

import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.io as pio

# === CONFIG: set your files here ===
FILE_T0 = r"C:\path\to\ratings_05-30.xlsx"   # earlier date
FILE_T1 = r"C:\path\to\ratings_08-29.xlsx"   # later date
SHEET_NAME = "Holdings"
ID_COL = "Identifier"
RATING_COL = "Lowest Rating"

# Buckets best -> worst (left→right). Add "D" if you track defaults.
RATING_ORDER: List[str] = ["AAA", "AA", "A", "BBB", "BB", "B", "CCC", "CC", "C"]

# === Rating mapping ===
def bucketize(raw: str) -> str:
    if raw is None or str(raw).strip() == "":
        return None
    s = str(raw).strip().upper()
    s = s.replace(" ", "").replace("+", "").replace("-", "")
    if s in {"NR", "N/R", "NOTRATED", "NA"}:
        return None
    if s in {"AAA", "AA", "A", "BBB", "BB", "B", "CCC", "CC", "C"}:
        return s
    moody_patterns = [
        (r"AAA", "AAA"),
        (r"AA[123]?", "AA"),
        (r"A[123]?", "A"),
        (r"BAA[123]?", "BBB"),
        (r"BA[123]?", "BB"),
        (r"B[123]?", "B"),
        (r"CAA[123]?", "CCC"),
        (r"CA", "CC"),
        (r"CCC", "CCC"),
        (r"CC", "CC"),
        (r"C", "C"),
    ]
    for pat, bucket in moody_patterns:
        if re.fullmatch(pat, s):
            return bucket
    if "D" in RATING_ORDER and re.fullmatch(r"(D|DEF(AULT)?)", s):
        return "D"
    return None

def load_sheet(path: str) -> pd.DataFrame:
    df = pd.read_excel(path, sheet_name=SHEET_NAME, dtype=str, usecols=[ID_COL, RATING_COL])
    df.columns = [c.strip() for c in df.columns]
    df[ID_COL] = df[ID_COL].astype(str).str.strip()
    df["bucket"] = df[RATING_COL].map(bucketize)
    df = df.dropna(subset=[ID_COL, "bucket"])

    # If duplicates per Identifier exist, keep the WORST (lowest) by our order
    order = {r: i for i, r in enumerate(RATING_ORDER)}
    df = (
        df.sort_values(by=["bucket"], key=lambda s: s.map(order))
          .drop_duplicates(subset=[ID_COL], keep="last")
          [[ID_COL, "bucket"]]
    )
    return df

def compute_blocks(t0: pd.DataFrame, t1: pd.DataFrame):
    common = t0.merge(t1, on=ID_COL, how="inner", suffixes=("_t0", "_t1"))
    counts = pd.crosstab(common["bucket_t0"], common["bucket_t1"]).reindex(
        index=RATING_ORDER, columns=RATING_ORDER, fill_value=0
    )
    disappeared = t0[~t0[ID_COL].isin(t1[ID_COL])]
    paid_off = disappeared.groupby("bucket")[ID_COL].nunique().reindex(RATING_ORDER).fillna(0).astype(int)
    newcomers = t1[~t1[ID_COL].isin(t0[ID_COL])]
    new_by_to = newcomers.groupby("bucket")[ID_COL].nunique().reindex(RATING_ORDER).fillna(0).astype(int)
    starting = t0.groupby("bucket")[ID_COL].nunique().reindex(RATING_ORDER).fillna(0).astype(int)
    ending   = t1.groupby("bucket")[ID_COL].nunique().reindex(RATING_ORDER).fillna(0).astype(int)
    return counts, paid_off, new_by_to, starting, ending

# === Plotly helpers ===
def write_fig(fig: go.Figure, base: Path, suffix: str):
    html_path = base.with_name(base.name + f"_{suffix}.html")
    pio.write_html(fig, file=str(html_path), include_plotlyjs="cdn", full_html=True)
    # Optional PNG (requires kaleido)
    try:
        png_path = base.with_name(base.name + f"_{suffix}.png")
        pio.write_image(fig, str(png_path), scale=2, width=1200, height=800)
    except Exception:
        pass
    return html_path

def directional_heatmap(pct: pd.DataFrame, title: str) -> go.Figure:
    """
    Creates a direction-aware heatmap:
      - Upgrades (left) = negative z -> green
      - Downgrades (right) = positive z -> red
      - Diagonal = grey overlay
    pct should be row-normalized % for transitions only (no Paid Off).
    """
    n = len(pct)
    # Build a sign matrix based on column index minus row index
    idx = {r: i for i, r in enumerate(pct.index)}
    idy = {c: j for j, c in enumerate(pct.columns)}
    sign = np.zeros_like(pct.values, dtype=float)
    for i, r in enumerate(pct.index):
        for j, c in enumerate(pct.columns):
            sign[i, j] = np.sign(idy[c] - idx[r])  # right (downgrade)=+1, left (upgrade)=-1, diagonal=0
    z = sign * pct.values  # retains magnitude (percentage), adds direction sign
    text = [[f"{pct.iat[i,j]:.1f}%" for j in range(n)] for i in range(n)]

    # Base heatmap (diverging colors, centered at 0)
    hm = go.Heatmap(
        z=z,
        x=list(pct.columns),
        y=list(pct.index),
        colorscale="RdYlGn_r",  # red for positive (downgrade), green for negative (upgrade)
        zmid=0,
        colorbar=dict(title="Direction-weighted %", tickformat=".0f"),
        hovertemplate="From: %{y}<br>To: %{x}<br>%{text}<extra></extra>",
        text=text,
        showscale=True,
    )

    # Overlay a second heatmap for diagonal cells to force grey
    diag_mask = np.eye(n, dtype=bool)
    diag_z = np.where(diag_mask, 1, np.nan)  # only diagonal cells have a value
    diag = go.Heatmap(
        z=diag_z,
        x=list(pct.columns),
        y=list(pct.index),
        colorscale=[ [0, "#D9D9D9"], [1, "#D9D9D9"] ],
        showscale=False,
        hoverinfo="skip",
        zauto=False,
        zmin=0, zmax=1,
        opacity=1.0,
    )

    fig = go.Figure(data=[hm, diag])
    fig.update_layout(
        title=title,
        xaxis_title="To bucket",
        yaxis_title="From bucket",
        xaxis=dict(constrain="domain", tickmode="array", tickvals=list(range(n)), ticktext=list(pct.columns)),
        yaxis=dict(autorange="reversed"),  # top = best rating
        margin=dict(l=70, r=20, t=70, b=60),
        template="plotly_white",
    )
    return fig

def counts_heatmap(counts: pd.DataFrame, title: str) -> go.Figure:
    text = counts.astype(int).astype(str).values
    fig = go.Figure(data=go.Heatmap(
        z=counts.values,
        x=list(counts.columns),
        y=list(counts.index),
        colorscale="Blues",
        hovertemplate="From: %{y}<br>To: %{x}<br>Count: %{z}<extra></extra>",
        showscale=True,
    ))
    # Annotate numbers
    for i, r in enumerate(counts.index):
        for j, c in enumerate(counts.columns):
            fig.add_annotation(x=c, y=r, text=text[i][j], showarrow=False, font=dict(size=11))
    fig.update_layout(
        title=title,
        xaxis_title="To bucket",
        yaxis_title="From bucket",
        yaxis=dict(autorange="reversed"),
        margin=dict(l=70, r=20, t=70, b=60),
        template="plotly_white",
    )
    return fig

def sankey_flows(counts: pd.DataFrame, title: str) -> go.Figure:
    """ Sankey with left nodes = 'From' buckets, right nodes = 'To' buckets """
    buckets = list(counts.index)
    n = len(buckets)
    labels = [f"{b} (From)" for b in buckets] + [f"{b} (To)" for b in buckets]
    # Color links by direction
    link_src, link_tgt, link_val, link_color, link_label = [], [], [], [], []

    for i, fr in enumerate(buckets):
        for j, to in enumerate(buckets):
            v = int(counts.iat[i, j])
            if v == 0:
                continue
            link_src.append(i)
            link_tgt.append(n + j)
            link_val.append(v)
            # Directional color
            if j == i:
                col = "rgba(150,150,150,0.7)"   # same → grey
            elif j > i:
                col = "rgba(203, 65, 84, 0.7)"  # downgrade → red-ish
            else:
                col = "rgba(0, 150, 100, 0.7)"  # upgrade → green-ish
            link_color.append(col)
            link_label.append(f"{fr} → {to}: {v}")

    node_colors = ["#CCCCCC"] * n + ["#EAEAEA"] * n
    fig = go.Figure(data=[go.Sankey(
        arrangement="snap",
        node=dict(
            pad=15, thickness=18,
            label=labels,
            color=node_colors
        ),
        link=dict(
            source=link_src,
            target=link_tgt,
            value=link_val,
            color=link_color,
            label=link_label,
            hovertemplate="%{label}<extra></extra>"
        )
    )])
    fig.update_layout(
        title=title,
        font=dict(size=12),
        margin=dict(l=20, r=20, t=60, b=20),
        template="plotly_white",
    )
    return fig

# === Pipeline ===
def run(file_t0: str, file_t1: str, out_prefix: str):
    t0 = load_sheet(file_t0)
    t1 = load_sheet(file_t1)
    counts, paid_off, new_secs, starting, ending = compute_blocks(t0, t1)

    # Row-normalized % on transitions (excludes Paid Off)
    denom = counts.sum(axis=1).replace(0, np.nan)
    pct = (counts.div(denom, axis=0) * 100.0).fillna(0.0).round(2)
    pct = pct.reindex(index=RATING_ORDER, columns=RATING_ORDER, fill_value=0)

    base = Path(out_prefix).with_suffix("")

    # 1) Direction-aware % heatmap
    fig_dir = directional_heatmap(pct, "Rating Migration (Row-normalized %) — Upgrades/Weakenings Highlighted")
    write_fig(fig_dir, base, "heatmap_percent_directional")

    # 2) Counts heatmap
    fig_counts = counts_heatmap(counts.reindex(index=RATING_ORDER, columns=RATING_ORDER, fill_value=0),
                                "Rating Migration Counts (From → To)")
    write_fig(fig_counts, base, "heatmap_counts")

    # 3) Sankey flows
    fig_sankey = sankey_flows(counts.reindex(index=RATING_ORDER, columns=RATING_ORDER, fill_value=0),
                              "Flows From → To (Counts)")
    write_fig(fig_sankey, base, "sankey_flows")

    # Also save an index HTML that links to all charts
    index_html = base.with_name(base.name + "_dashboard.html")
    parts = [
        base.name + "_heatmap_percent_directional.html",
        base.name + "_heatmap_counts.html",
        base.name + "_sankey_flows.html",
    ]
    html_links = "\n".join(f'<li><a href="{p}">{p}</a></li>' for p in parts)
    with open(index_html, "w", encoding="utf-8") as f:
        f.write(f"""<!doctype html>
<html><head><meta charset="utf-8"><title>{base.name} Dashboard</title></head>
<body style="font-family:Arial,Helvetica,sans-serif">
<h2>{base.name} — Rating Migration Dashboard</h2>
<ol>
{html_links}
</ol>
<p>Tip: open each chart and use the camera icon to download as PNG if kaleido is not available.</p>
</body></html>""")

    print("Saved HTML charts:")
    for p in parts + [index_html.name]:
        print(" -", p)
    print("\nIf you installed 'kaleido', PNG images were also written alongside the HTML files.")

if __name__ == "__main__":
    out_name = Path(FILE_T0).stem + "_to_" + Path(FILE_T1).stem
    run(FILE_T0, FILE_T1, out_prefix=out_name)
