import numpy as np
import pandas as pd

# --- your function: must return 3 values as a Series (=> 3 columns) ---
def f(row, W, A):
    # replace this with your real logic
    return pd.Series({
        "out1": row["x"] * W + A,
        "out2": row["y"] * A + W,
        "out3": row["x"] - row["y"] + (W - A),
    })

# --- example input df (remove if you already have df) ---
# df = pd.DataFrame({"x":[1,2,3], "y":[10,20,30]})

W0 = 1.00
A0 = 1.00
stress_steps = np.array([0.01, 0.02, 0.03, 0.04, 0.05])

def run_apply_stress(df, func, W0, A0, steps):
    results = []

    scenarios = [
        ("A_down",         lambda s: (W0,      A0 - s)),
        ("W_up",           lambda s: (W0 + s,  A0)),
        ("A_down_W_up",    lambda s: (W0 + s,  A0 - s)),
    ]

    for stress_type, param_fn in scenarios:
        for s in steps:
            W, A = param_fn(s)

            out = df.apply(func, axis=1, W=W, A=A)  # expects Series per row (3 outputs)
            out = out.rename(columns=lambda c: f"{c}") if isinstance(out, pd.DataFrame) else out.to_frame()

            out = out.reset_index(drop=True)
            out.insert(0, "StressType", stress_type)
            out.insert(1, "Stress", float(s))
            out.insert(2, "W", float(W))
            out.insert(3, "A", float(A))

            results.append(out)

    return pd.concat(results, ignore_index=True)

# usage:
# final_df = run_apply_stress(df, f, W0, A0, stress_steps)
# print(final_df.head())
