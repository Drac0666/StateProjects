import pandas as pd
import numpy as np

def limits_utilization_report(DF: pd.DataFrame, limits: pd.DataFrame) -> pd.DataFrame:
    # --- checks ---
    df_cols = {"Parent_Asset_Class", "Asset_Class", "Sub_Asset_Class", "Exposure(USD)"}
    lim_cols = {"LimitID", "Level", "parent_Asset_Class", "Asset_Class", "Sub_Asset_Class",
                "LimitAmount", "LimitCurrency", "LimitName"}

    missing_df = df_cols - set(DF.columns)
    missing_lim = lim_cols - set(limits.columns)
    if missing_df:
        raise SystemExit(f"Critical Error: DF missing columns: {sorted(missing_df)}")
    if missing_lim:
        raise SystemExit(f"Critical Error: limits missing columns: {sorted(missing_lim)}")

    # --- aggregate exposures from DF for each level ---
    exp_parent = (DF.groupby(["Parent_Asset_Class"], dropna=False)["Exposure(USD)"]
                    .sum().reset_index().rename(columns={"Exposure(USD)": "Exposure"}))

    exp_asset = (DF.groupby(["Parent_Asset_Class", "Asset_Class"], dropna=False)["Exposure(USD)"]
                   .sum().reset_index().rename(columns={"Exposure(USD)": "Exposure"}))

    exp_sub = (DF.groupby(["Parent_Asset_Class", "Asset_Class", "Sub_Asset_Class"], dropna=False)["Exposure(USD)"]
                 .sum().reset_index().rename(columns={"Exposure(USD)": "Exposure"}))

    # --- normalize naming (limits -> DF naming) ---
    lim = limits.copy()
    lim["Level"] = lim["Level"].astype(str).str.upper()
    lim = lim.rename(columns={"parent_Asset_Class": "Parent_Asset_Class"})

    # --- split and merge correct exposure depending on Level ---
    lim_parent = lim[lim["Level"].eq("PARENT")].merge(
        exp_parent, on=["Parent_Asset_Class"], how="left"
    )
    lim_asset = lim[lim["Level"].eq("ASSET")].merge(
        exp_asset, on=["Parent_Asset_Class", "Asset_Class"], how="left"
    )
    lim_sub = lim[lim["Level"].eq("SUB")].merge(
        exp_sub, on=["Parent_Asset_Class", "Asset_Class", "Sub_Asset_Class"], how="left"
    )

    out = pd.concat([lim_parent, lim_asset, lim_sub], ignore_index=True)
    out["Exposure"] = out["Exposure"].fillna(0.0)

    # --- utilization ---
    out["%Utilization"] = np.where(
        out["LimitAmount"].astype(float) != 0,
        out["Exposure"].astype(float) / out["LimitAmount"].astype(float),
        np.nan
    ) * 100

    # --- display name indent based on Level ---
    prefix = {"PARENT": "", "ASSET": "--- ", "SUB": "------ "}
    out["Limit Name"] = out["Level"].map(prefix).fillna("") + out["LimitName"].astype(str)

    # --- sorting: Parent -> Asset -> Sub within hierarchy ---
    level_rank = {"PARENT": 0, "ASSET": 1, "SUB": 2}
    out["_lvl"] = out["Level"].map(level_rank).fillna(9).astype(int)

    out["_sort_parent"] = out["Parent_Asset_Class"].astype(str)
    out["_sort_asset"] = out["Asset_Class"].fillna("").astype(str)
    out["_sort_sub"] = out["Sub_Asset_Class"].fillna("").astype(str)

    out = out.sort_values(
        ["_sort_parent", "_lvl", "_sort_asset", "_sort_sub", "LimitName"],
        kind="stable"
    )

    # --- final shape exactly as requested ---
    result = out[["Limit Name", "Exposure", "LimitAmount", "%Utilization"]].reset_index(drop=True)
    return result
