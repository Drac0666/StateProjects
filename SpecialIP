# Python 3.9
import re
import pandas as pd


# ============== CONFIG ==============
MAIN_DATA_PATH = r"MainData.xlsx"                      # or .csv
ASSET_CLASS_MAPPING_PATH = r"AssetClassMapping.xlsx"   # Deal Type, SSFA_AssetClass
COLUMN_MAPPING_PATH = r"ColumnMapping.xlsx"            # columns named by AssetClass
EXCEPTIONS_PATH = r"AssetClassExceptions.xlsx"         # DealTrancheID, SSFA_AssetClass (or None)
OUTPUT_PATH = r"Output_By_AssetClass.xlsx"

MAIN_DATA_SHEET = 0
ASSET_CLASS_MAPPING_SHEET = 0
COLUMN_MAPPING_SHEET = 0
EXCEPTIONS_SHEET = 0

DEAL_TYPE_COL = "Deal Type"
ASSET_CLASS_COL = "SSFA_AssetClass"
DEAL_TRANCHE_ID_COL = "DealTrancheID"

LATEST_UPDATE_COL = "Latest Update"
AS_OF_DATE = "2025-12-30"
STALE_THRESHOLD_DAYS = 91

ERROR_CLASS_VALUE = "Error"
ERROR_SHEET_NAME = "Errors"
STALE_SHEET_NAME = "StaleData"

# <-- NEW: define asset class tab order here (exact values as in SSFA_AssetClass)
ASSET_CLASS_EXPORT_ORDER = [
    "CMBS",
    "RMBS",
    "ABS",
    "CLO",
]
# ====================================


def read_table(path: str, sheet=0) -> pd.DataFrame:
    if path is None:
        return None
    p = path.lower()
    if p.endswith((".xlsx", ".xlsm", ".xls")):
        return pd.read_excel(path, sheet_name=sheet)
    if p.endswith(".csv"):
        return pd.read_csv(path)
    raise ValueError(f"Unsupported file type: {path}")


def sanitize_sheet_name(name: str) -> str:
    if name is None:
        name = "Unknown"
    name = str(name).strip()
    name = re.sub(r"[:\\/?*\[\]]", "_", name)
    return (name[:31] if len(name) > 31 else name) or "Sheet"


def build_assetclass_lookup(asset_map_df: pd.DataFrame) -> dict:
    required = {DEAL_TYPE_COL, ASSET_CLASS_COL}
    missing = required - set(asset_map_df.columns)
    if missing:
        raise KeyError(f"AssetClassMapping missing required columns: {sorted(missing)}")

    asset_map_df = asset_map_df[[DEAL_TYPE_COL, ASSET_CLASS_COL]].dropna(subset=[DEAL_TYPE_COL])
    asset_map_df[DEAL_TYPE_COL] = asset_map_df[DEAL_TYPE_COL].astype(str).str.strip()
    asset_map_df[ASSET_CLASS_COL] = asset_map_df[ASSET_CLASS_COL].astype(str).str.strip()
    return dict(zip(asset_map_df[DEAL_TYPE_COL], asset_map_df[ASSET_CLASS_COL]))


def read_column_mapping(path: str) -> dict:
    cm = pd.read_excel(path, sheet_name=COLUMN_MAPPING_SHEET)
    mapping = {}
    for asset_class in cm.columns:
        cols = cm[asset_class].dropna().astype(str).map(str.strip)
        cols = [c for c in cols.tolist() if c]
        mapping[str(asset_class).strip()] = cols
    return mapping


def build_exception_lookup(ex_df: pd.DataFrame) -> dict:
    required = {DEAL_TRANCHE_ID_COL, ASSET_CLASS_COL}
    missing = required - set(ex_df.columns)
    if missing:
        raise KeyError(f"Exceptions file missing required columns: {sorted(missing)}")

    ex_df = ex_df[[DEAL_TRANCHE_ID_COL, ASSET_CLASS_COL]].dropna(subset=[DEAL_TRANCHE_ID_COL])
    ex_df[DEAL_TRANCHE_ID_COL] = ex_df[DEAL_TRANCHE_ID_COL].astype(str).str.strip()
    ex_df[ASSET_CLASS_COL] = ex_df[ASSET_CLASS_COL].astype(str).str.strip()
    return dict(zip(ex_df[DEAL_TRANCHE_ID_COL], ex_df[ASSET_CLASS_COL]))


def compute_stale_flags(df: pd.DataFrame, as_of_date: str) -> pd.DataFrame:
    if LATEST_UPDATE_COL not in df.columns:
        raise KeyError(f"Main data is missing required column: '{LATEST_UPDATE_COL}'")

    as_of_dt = pd.to_datetime(as_of_date, errors="coerce")
    if pd.isna(as_of_dt):
        raise ValueError(f"AS_OF_DATE could not be parsed: {as_of_date!r} (recommend YYYY-MM-DD)")

    df["_as_of_dt"] = as_of_dt
    df["_latest_update_dt"] = pd.to_datetime(df[LATEST_UPDATE_COL], errors="coerce")

    days = (df["_as_of_dt"] - df["_latest_update_dt"]).dt.days
    days = days.where(days >= 0, 0)
    df["DaysSinceLatestUpdate"] = days

    df["_is_stale"] = df["_latest_update_dt"].isna() | (df["DaysSinceLatestUpdate"] > STALE_THRESHOLD_DAYS)
    return df


def drop_internal_cols_for_output(df: pd.DataFrame) -> pd.DataFrame:
    cols_to_drop = {
        DEAL_TYPE_COL,
        ASSET_CLASS_COL,
        "_as_of_dt",
        "_latest_update_dt",
        "_is_stale",
    }
    keep = [c for c in df.columns if c not in cols_to_drop]
    return df.loc[:, keep].copy()


def ordered_asset_classes(present_asset_classes) -> list:
    """
    Returns export order:
    1) items from ASSET_CLASS_EXPORT_ORDER that are present (in that order)
    2) remaining present asset classes not listed (alphabetical)
    """
    present_set = set(present_asset_classes)

    ordered = [ac for ac in ASSET_CLASS_EXPORT_ORDER if ac in present_set]
    remaining = sorted([ac for ac in present_set if ac not in set(ordered)])
    return ordered + remaining


def main():
    df = read_table(MAIN_DATA_PATH, sheet=MAIN_DATA_SHEET)

    asset_map_df = read_table(ASSET_CLASS_MAPPING_PATH, sheet=ASSET_CLASS_MAPPING_SHEET)
    deal_to_asset = build_assetclass_lookup(asset_map_df)

    column_mapping = read_column_mapping(COLUMN_MAPPING_PATH)

    exception_lookup = {}
    if EXCEPTIONS_PATH:
        ex_df = read_table(EXCEPTIONS_PATH, sheet=EXCEPTIONS_SHEET)
        exception_lookup = build_exception_lookup(ex_df)

    # Assign SSFA_AssetClass
    for col in (DEAL_TYPE_COL, DEAL_TRANCHE_ID_COL):
        if col not in df.columns:
            raise KeyError(f"Main data is missing required column: '{col}'")

    df[DEAL_TYPE_COL] = df[DEAL_TYPE_COL].astype(str).str.strip()
    df[DEAL_TRANCHE_ID_COL] = df[DEAL_TRANCHE_ID_COL].astype(str).str.strip()

    df[ASSET_CLASS_COL] = df[DEAL_TYPE_COL].map(deal_to_asset).fillna(ERROR_CLASS_VALUE)

    override = df[DEAL_TRANCHE_ID_COL].map(exception_lookup)
    df.loc[override.notna(), ASSET_CLASS_COL] = override[override.notna()].astype(str)

    # Stale flags
    df = compute_stale_flags(df, AS_OF_DATE)

    # Special frames (no duplicates)
    errors_df = df[df[ASSET_CLASS_COL].astype(str) == ERROR_CLASS_VALUE].copy()
    stale_df = df[(df["_is_stale"]) & (df[ASSET_CLASS_COL].astype(str) != ERROR_CLASS_VALUE)].copy()

    # Asset class frames = non-error & non-stale only
    base_for_asset_sheets = df[(df[ASSET_CLASS_COL].astype(str) != ERROR_CLASS_VALUE) & (~df["_is_stale"])].copy()

    present_asset_classes = base_for_asset_sheets_
