import plotly.graph_objs as go
import plotly.offline as pyo
import numpy as np
import pandas as pd

# Assuming you have a function that calculates RW based on Attach and DQ
def calculate_rw(attach, dq, other_params):
    # Replace this with your actual calculation
    # For demonstration, let's assume RW = attach * dq * some_factor + some_constant
    some_factor = 0.5
    some_constant = 10
    return attach * dq * some_factor + some_constant

# Define the range of Attach and DQ values
attach_values = np.linspace(0.01, 0.99, 50)  # 50 points between 0.01 and 0.99
dq_values = np.linspace(0.01, 0.99, 50)     # 50 points between 0.01 and 0.99

# Create a grid of Attach and DQ values
attach_grid, dq_grid = np.meshgrid(attach_values, dq_values)

# Other parameters that your function might need
other_params = {
    'param1': 1.0,
    'param2': 2.0,
    # Add other parameters as needed
}

# Calculate RW for each combination of Attach and DQ
rw_values = np.zeros_like(attach_grid)
for i in range(len(attach_values)):
    for j in range(len(dq_values)):
        rw_values[i, j] = calculate_rw(attach_grid[i, j], dq_grid[i, j], other_params)

# Store results in a DataFrame
results = pd.DataFrame({
    'Attach': attach_grid.flatten(),
    'DQ': dq_grid.flatten(),
    'RW': rw_values.flatten()
})

# Print the first few rows of the DataFrame
print("Results DataFrame:")
print(results.head())

# Create a custom colorscale
# Colorscale is a list of [threshold, color] pairs
# For RW > 0.2, we use red; otherwise, we use the Viridis colorscale
colorscale = [
    [0, 'blue'],        # RW <= 0.2
    [0.2, 'blue'],      # RW = 0.2
    [0.2, 'red'],       # RW > 0.2 (transition to red)
    [1, 'red']          # RW = max value
]

# Create the 3D surface plot
surface = go.Surface(
    x=attach_grid,
    y=dq_grid,
    z=rw_values,
    surfacecolor=rw_values,  # Use RW values to determine color
    colorscale=colorscale,   # Apply the custom colorscale
    name='RW',
    hovertemplate=(
        '<b>Attach</b>: %{x:.2f}<br>'
