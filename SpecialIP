#!/usr/bin/env python3
"""
Generate an HTML report with Plotly bar charts:
For each CUSIP -> Collateral Loss by scenario.

Usage:
  python cusip_collateral_loss_report.py --csv path/to/data.csv [--out report.html] [--title "My Report"]
"""

import argparse
import html
import sys
from pathlib import Path

import pandas as pd
import plotly.express as px
import plotly.io as pio


def build_report_html(fig_divs, title="CUSIP Collateral Loss Report"):
    """Wrap multiple Plotly figure <div>s into a single HTML document with a simple TOC."""
    # Minimal CSS for readability
    css = """
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; }
    .toc { margin-bottom: 24px; padding: 16px; background: #f7f7f7; border-radius: 12px; }
    .toc h2 { margin: 0 0 8px 0; font-size: 18px; }
    .toc a { margin-right: 12px; display: inline-block; text-decoration: none; }
    .chart { margin: 28px 0; }
    .chart h2 { font-size: 18px; margin: 0 0 8px 0; }
    hr { border: 0; height: 1px; background: #e6e6e6; margin: 24px 0; }
    """

    toc_links = "\n".join(f'<a href="#{sec_id}">{html.escape(label)}</a>'
                          for sec_id, label, _ in fig_divs)

    sections = []
    for sec_id, label, div_html in fig_divs:
        sections.append(
            f'<section class="chart" id="{sec_id}">'
            f'<h2>{html.escape(label)}</h2>'
            f'{div_html}'
            f'</section>'
            f'<hr/>'
        )

    sections_html = "\n".join(sections)

    return f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>{html.escape(title)}</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>{css}</style>
</head>
<body>
  <h1>{html.escape(title)}</h1>
  <div class="toc">
    <h2>Jump to CUSIP</h2>
    {toc_links}
  </div>
  {sections_html}
</body>
</html>
"""


def main():
    ap = argparse.ArgumentParser(description="Build Plotly HTML report of Collateral Loss by scenario for each CUSIP.")
    ap.add_argument("--csv", required=True, help="Path to input CSV with columns: CUSIP, scenario, Collateral Loss")
    ap.add_argument("--out", default=None, help="Path to output HTML file (default: <csv_stem>_cusip_report.html)")
    ap.add_argument("--title", default="CUSIP Collateral Loss Report", help="Title for the HTML report")
    ap.add_argument("--sort", choices=["value_desc", "scenario_asc", "none"], default="scenario_asc",
                    help="How to order bars within each chart")
    args = ap.parse_args()

    csv_path = Path(args.csv)
    if not csv_path.exists():
        print(f"❌ CSV not found: {csv_path}", file=sys.stderr)
        sys.exit(1)

    out_path = Path(args.out) if args.out else csv_path.with_name(f"{csv_path.stem}_cusip_report.html")

    # Read data
    df = pd.read_csv(csv_path)

    # Normalize column names to find required fields robustly
    colmap = {c.lower().strip(): c for c in df.columns}
    required = {"cusip", "scenario", "collateral loss"}
    missing = [c for c in required if c not in colmap]
    if missing:
        print(f"❌ Missing required columns: {missing}\n"
              f"   Found columns: {list(df.columns)}", file=sys.stderr)
        sys.exit(2)

    C_CUSIP = colmap["cusip"]
    C_SCEN = colmap["scenario"]
    C_LOSS = colmap["collateral loss"]

    # Clean & coerce
    work = df[[C_CUSIP, C_SCEN, C_LOSS]].copy()
    work[C_SCEN] = work[C_SCEN].astype(str)
    # Coerce Collateral Loss to numeric, keep NaN if not convertible
    work[C_LOSS] = pd.to_numeric(work[C_LOSS], errors="coerce").fillna(0.0)

    # Build figures per CUSIP
    fig_divs = []
    # Keep a stable scenario order as it first appears (unless overridden)
    scenario_order_global = list(work[C_SCEN].drop_duplicates())

    for cusip, g in work.groupby(C_CUSIP, sort=False):
        g = g.copy()

        if args.sort == "value_desc":
            # order scenarios by Collateral Loss descending (sum per scenario)
            order = (g.groupby(C_SCEN, as_index=False)[C_LOSS]
                       .sum()
                       .sort_values(C_LOSS, ascending=False)[C_SCEN]
                       .tolist())
        elif args.sort == "scenario_asc":
            order = sorted(g[C_SCEN].unique().tolist(), key=lambda x: (str(x).lower(), str(x)))
        else:  # "none" -> keep appearance order
            order = [s for s in scenario_order_global if s in set(g[C_SCEN])]

        # enforce categorical order
        g[C_SCEN] = pd.Categorical(g[C_SCEN], categories=order, ordered=True)

        # If multiple rows per scenario for a CUSIP, aggregate (sum) to one bar each
        plot_df = g.groupby(C_SCEN, as_index=False)[C_LOSS].sum()

        fig = px.bar(
            plot_df,
            x=C_SCEN,
            y=C_LOSS,
            text=C_LOSS,
            labels={C_SCEN: "Scenario", C_LOSS: "Collateral Loss"},
            title=f"CUSIP {cusip} — Collateral Loss by Scenario",
        )
        # Nice formatting
        fig.update_traces(texttemplate="%{text:.2f}", textposition="outside")
        fig.update_layout(
            xaxis_title="Scenario",
            yaxis_title="Collateral Loss",
            uniformtext_minsize=8,
            uniformtext_mode="hide",
            bargap=0.25,
            margin=dict(l=40, r=20, t=60, b=40),
            height=420,
        )

        # Create an id and section label
        sec_id = f"cusip_{str(cusip).strip().replace(' ', '_').replace('/', '_')}"
        label = f"CUSIP {cusip}"

        # Convert to a div without adding plotly.js (we include once globally)
        div_html = pio.to_html(fig, include_plotlyjs=False, full_html=False)
        fig_divs.append((sec_id, label, div_html))

    html_doc = build_report_html(fig_divs, title=args.title)
    out_path.write_text(html_doc, encoding="utf-8")
    print(f"✅ Report written to: {out_path.resolve()}")


if __name__ == "__main__":
    main()
