# Python 3.9
# ------------------------------------------------------------
# What this script does:
# 1) Reads MainData into df
# 2) Reads AssetClassMapping (columns: "Deal Type", "SSFA_AssetClass")
# 3) Assigns SSFA_AssetClass to df based on df["Deal Type"]
# 4) Reads ColumnMapping.xlsx (columns named like asset classes, e.g. "CMBS")
# 5) Splits df into separate DataFrames per SSFA_AssetClass
#    - If SSFA_AssetClass == "Error": NO column filtering (export as-is)
#    - Else: filter columns based on the matching asset-class column in ColumnMapping
# 6) Exports all DataFrames to one Excel file with separate tabs named by asset class
# ------------------------------------------------------------

import re
import pandas as pd


# ============== CONFIG ==============
MAIN_DATA_PATH = r"MainData.xlsx"               # or .csv
ASSET_CLASS_MAPPING_PATH = r"AssetClassMapping.xlsx"  # must contain: Deal Type, SSFA_AssetClass
COLUMN_MAPPING_PATH = r"ColumnMapping.xlsx"     # columns named by AssetClass, cells list column names to keep
OUTPUT_PATH = r"Output_By_AssetClass.xlsx"

MAIN_DATA_SHEET = 0            # sheet index or name if Excel
ASSET_CLASS_MAPPING_SHEET = 0  # sheet index or name
COLUMN_MAPPING_SHEET = 0       # sheet index or name

DEAL_TYPE_COL = "Deal Type"
ASSET_CLASS_COL = "SSFA_AssetClass"

ERROR_CLASS_VALUE = "Error"
# ====================================


def read_main_data(path: str) -> pd.DataFrame:
    """Reads main data into a DataFrame (supports .xlsx/.xlsm/.xls and .csv)."""
    if path.lower().endswith((".xlsx", ".xlsm", ".xls")):
        return pd.read_excel(path, sheet_name=MAIN_DATA_SHEET)
    if path.lower().endswith(".csv"):
        return pd.read_csv(path)
    raise ValueError(f"Unsupported main data file type: {path}")


def sanitize_sheet_name(name: str) -> str:
    """Excel sheet name rules: max 31 chars, cannot contain : \ / ? * [ ]"""
    if name is None:
        name = "Unknown"
    name = str(name).strip()
    name = re.sub(r"[:\\/?*\[\]]", "_", name)
    return (name[:31] if len(name) > 31 else name) or "Sheet"


def build_assetclass_lookup(asset_map_df: pd.DataFrame) -> dict:
    """Build mapping: Deal Type -> SSFA_AssetClass."""
    required = {DEAL_TYPE_COL, ASSET_CLASS_COL}
    missing = required - set(asset_map_df.columns)
    if missing:
        raise KeyError(f"AssetClassMapping missing required columns: {sorted(missing)}")

    # Keep last occurrence if duplicates exist
    asset_map_df = asset_map_df[[DEAL_TYPE_COL, ASSET_CLASS_COL]].dropna(subset=[DEAL_TYPE_COL])
    asset_map_df[DEAL_TYPE_COL] = asset_map_df[DEAL_TYPE_COL].astype(str).str.strip()
    asset_map_df[ASSET_CLASS_COL] = asset_map_df[ASSET_CLASS_COL].astype(str).str.strip()

    return dict(zip(asset_map_df[DEAL_TYPE_COL], asset_map_df[ASSET_CLASS_COL]))


def read_column_mapping(path: str) -> dict:
    """
    Reads ColumnMapping.xlsx and returns:
      { "CMBS": ["colA", "colB", ...], "RMBS": [...], ... }
    Assumption: each asset class is a column header; the cells under it are column names to KEEP.
    """
    cm = pd.read_excel(path, sheet_name=COLUMN_MAPPING_SHEET)

    mapping = {}
    for asset_class in cm.columns:
        # drop blanks, cast to str, strip
        cols = (
            cm[asset_class]
            .dropna()
            .astype(str)
            .map(str.strip)
        )
        # remove empty strings
        cols = [c for c in cols.tolist() if c]
        mapping[str(asset_class).strip()] = cols

    return mapping


def main():
    # 1) Read files
    df = read_main_data(MAIN_DATA_PATH)

    asset_map_df = pd.read_excel(ASSET_CLASS_MAPPING_PATH, sheet_name=ASSET_CLASS_MAPPING_SHEET)
    deal_to_asset = build_assetclass_lookup(asset_map_df)

    column_mapping = read_column_mapping(COLUMN_MAPPING_PATH)

    # 2) Assign SSFA_AssetClass based on Deal Type
    if DEAL_TYPE_COL not in df.columns:
        raise KeyError(f"Main data is missing required column: '{DEAL_TYPE_COL}'")

    df[DEAL_TYPE_COL] = df[DEAL_TYPE_COL].astype(str).str.strip()

    # map deal type -> asset class; anything not mapped becomes "Error"
    df[ASSET_CLASS_COL] = df[DEAL_TYPE_COL].map(deal_to_asset).fillna(ERROR_CLASS_VALUE)

    # 3) Split and filter
    mandatory_cols = [c for c in [DEAL_TYPE_COL, ASSET_CLASS_COL] if c in df.columns]

    # We'll export one sheet per distinct asset class in df
    asset_classes = sorted(df[ASSET_CLASS_COL].dropna().astype(str).unique().tolist())

    with pd.ExcelWriter(OUTPUT_PATH, engine="openpyxl") as writer:
        for ac in asset_classes:
            ac_str = str(ac)

            sub = df[df[ASSET_CLASS_COL].astype(str) == ac_str].copy()

            # If Error => do not filter columns
            if ac_str != ERROR_CLASS_VALUE:
                keep_cols_from_mapping = column_mapping.get(ac_str, [])

                # If mapping column doesn't exist or is empty, keep everything (safe fallback),
                # but you can change this behavior if you prefer "keep only mandatory".
                if keep_cols_from_mapping:
                    # Keep only columns that actually exist in sub + ensure mandatory columns stay
                    keep = []
                    for c in mandatory_cols + keep_cols_from_mapping:
                        if c in sub.columns and c not in keep:
                            keep.append(c)
                    sub = sub.loc[:, keep]
                # else: keep as-is

            sheet_name = sanitize_sheet_name(ac_str)
            sub.to_excel(writer, sheet_name=sheet_name, index=False)

    print(f"Done. Exported {len(asset_classes)} sheet(s) to: {OUTPUT_PATH}")


if __name__ == "__main__":
    main()
