import numpy as np

# Convert the DataFrame to a NumPy array for faster indexing
data_array = data.values  # Assuming `data` is a pandas DataFrame with 5 columns
num_data_points, num_columns = data_array.shape

# Preallocate results array for paths and columns
path_results = np.zeros((2, paths, num_columns))  # Shape: (monthly/annual, paths, columns)

# Generate all random indices for the loops in advance
monthly_random_indices = np.random.randint(0, num_data_points, (paths, 20))
annual_random_indices = np.random.randint(0, num_data_points, (paths, 231))  # 253 - 22 = 231

# Perform the simulation for each column
for col in range(num_columns):
    column_data = data_array[:, col]  # Extract the column for simulation

    for i in range(paths):
        # Monthly Path Result
        monthly_rates = column_data[monthly_random_indices[i]]
        monthly_product = np.prod(monthly_rates)  # Product for the monthly period
        path_results[0, i, col] = monthly_product

        # Annual Path Result (continuing from monthly product)
        annual_rates = column_data[annual_random_indices[i]]
        annual_product = monthly_product * np.prod(annual_rates)  # Continue from monthly
        path_results[1, i, col] = annual_product
import pandas as pd

# Define column names for the results
monthly_columns = [f"Monthly_Col_{col+1}" for col in range(num_columns)]
annual_columns = [f"Annual_Col_{col+1}" for col in range(num_columns)]

# Flatten the results and create a DataFrame
monthly_results = pd.DataFrame(path_results[0], columns=monthly_columns)
annual_results = pd.DataFrame(path_results[1], columns=annual_columns)

# Combine the results into a single DataFrame
results_df = pd.concat([monthly_results, annual_results], axis=1)

# Optional: Add a path index for identification
results_df.index.name = "Path_ID"
