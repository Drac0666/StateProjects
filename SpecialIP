# transition_matrix_ratings.py
# Python 3.9

from __future__ import annotations
import sys
import re
import pandas as pd
from pathlib import Path
from typing import Tuple, List

# Docelowy porządek ratingów (możesz dodać/zdjąć D jeśli u Ciebie nie występuje)
RATING_ORDER: List[str] = ["AAA", "AA", "A", "BBB", "BB", "B", "CCC", "CC", "C", "D"]

def read_any(path: str, usecols: List[str]) -> pd.DataFrame:
    p = Path(path)
    ext = p.suffix.lower()
    if ext in [".xlsx", ".xls"]:
        return pd.read_excel(p, dtype=str, usecols=usecols)
    elif ext in [".csv", ".txt"]:
        # spróbuj wykryć separator
        try:
            return pd.read_csv(p, dtype=str, usecols=usecols)
        except Exception:
            return pd.read_csv(p, dtype=str, usecols=usecols, sep=";")
    else:
        raise ValueError(f"Nieobsługiwane rozszerzenie pliku: {ext}")

def bucketize(raw: str) -> str:
    """
    Mapuje dowolny rating do bucketa: usuwa +/-, spacje, bierze prefiks pasujący do znanych.
    Przykłady: 'AA-', 'Aa2', 'bbb+' -> 'AA', 'A', 'BBB'
    Gdy brak dopasowania -> zwraca None (później to drop).
    """
    if raw is None:
        return None
    s = str(raw).strip().upper()

    # typowe czyszczenie
    s = s.replace(" ", "").replace("-", "").replace("+", "")

    # uproszczenia dla Moody's (Aaa -> AAA, Baa -> BBB itd.)
    s = s.replace("AAA", "AAA").replace("AA", "AA").replace("A", "A")
    s = s.replace("BAA", "BBB").replace("BB", "BB").replace("B", "B")
    s = s.replace("CAA", "CCC").replace("CCC", "CCC").replace("CC", "CC").replace("C", "C")

    # pełny match do któregoś z bucketów
    for b in RATING_ORDER:
        if s.startswith(b):
            return b

    # niektórzy zapisują 'DEFAULT', 'DEF', 'D'
    if re.fullmatch(r"(D|DEF(AULT)?)", s):
        return "D"

    return None

def load_ratings(path: str,
                 id_col: str = "Identifier",
                 rating_col: str = "Lowest Rating") -> pd.DataFrame:
    df = read_any(path, usecols=[id_col, rating_col]).copy()
    df.columns = [c.strip() for c in df.columns]
    df[id_col] = df[id_col].astype(str).str.strip()

    df["bucket"] = df[rating_col].map(bucketize)
    # wyrzuć wiersze bez mapowalnego ratingu lub identyfikatora
    df = df.dropna(subset=[id_col, "bucket"])
    # jeśli są duplikaty Identifier: weź najgorszy (najniższy) rating wg porządku
    order = {r: i for i, r in enumerate(RATING_ORDER)}
    df = df.sort_values(by=[id_col, "bucket"], key=lambda s: s.map(order)).groupby(id_col, as_index=False).last()
    return df[[id_col, "bucket"]]

def transition_matrix(
    file_t0: str,
    file_t1: str,
    id_col: str = "Identifier",
    rating_col: str = "Lowest Rating",
    rating_order: List[str] = None
) -> Tuple[pd.DataFrame, pd.DataFrame]:
    if rating_order is None:
        rating_order = RATING_ORDER

    d0 = load_ratings(file_t0, id_col, rating_col)
    d1 = load_ratings(file_t1, id_col, rating_col)

    # interesuje nas przekrój (tylko wspólne identyfikatory)
    common = d0.merge(d1, on=id_col, suffixes=("_t0", "_t1"), how="inner")

    # crosstab liczebności
    counts = pd.crosstab(
        common["bucket_t0"],
        common["bucket_t1"],
        dropna=False
    ).reindex(index=rating_order, columns=rating_order, fill_value=0)

    # procenty w wierszach (sumy wierszy = 100)
    pct = counts.div(counts.sum(axis=1).replace(0, 1), axis=0) * 100.0
    pct = pct.round(2)

    # ładne etykiety
    counts.index.name = "from\\to"
    pct.index.name = "from\\to"

    return counts, pct

def save_outputs(counts: pd.DataFrame, pct: pd.DataFrame, out_prefix: str) -> None:
    # CSV
    counts.to_csv(f"{out_prefix}_counts.csv", index=True)
    pct.to_csv(f\"{out_prefix}_pct.csv\", index=True)

    # Excel ze stylowaniem (diagonala pogrubiona)
    with pd.ExcelWriter(f\"{out_prefix}.xlsx\", engine=\"xlsxwriter\") as xw:
        counts.to_excel(xw, sheet_name=\"counts\")
        pct.to_excel(xw, sheet_name=\"percent\")

        wb = xw.book
        bold = wb.add_format({\"bold\": True})
        # pogrub kątną w arkuszu percent
        ws = xw.sheets[\"percent\"]
        # diagonala: wiersze/kolumny przesunięte o nagłówki (1-based w Excelu)
        n = pct.shape[0]
        for i in range(n):
            # w Excelu: rząd = i+2 (bo tytuł + nagłówki), kol = i+2
            ws.write(i+1+1, i+1+1, pct.iloc[i, i], bold)

if __name__ == \"__main__\":
    if len(sys.argv) < 3:
        print(\"Użycie: python transition_matrix_ratings.py <plik_t0> <plik_t1> [prefix_wyjścia]\")
        print(\"Obsługuję CSV/XLSX. Kolumny: 'Identifier', 'Lowest Rating'.\")
        sys.exit(1)

    file_t0, file_t1 = sys.argv[1], sys.argv[2]
    out_prefix = sys.argv[3] if len(sys.argv) > 3 else \"transition_matrix\"

    counts_df, pct_df = transition_matrix(file_t0, file_t1)
    save_outputs(counts_df, pct_df, out_prefix)

    print(\"=== Macierz liczebności ===\")
    print(counts_df)
    print(\"\\n=== Macierz procentowa (wiersze=100%) ===\")
    print(pct_df)
    print(f\"\\nZapisano: {out_prefix}_counts.csv, {out_prefix}_pct.csv oraz {out_prefix}.xlsx\")
