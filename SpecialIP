# Step 1: Group dataframes by vintage
vintage_groups = defaultdict(list)
for key, df in df_dict.items():
    # Use the first column dynamically to get the vintage
    vintage = df.loc['Vintage', df.columns[0]]
    vintage_groups[vintage].append((key, df))  # Store the key along with the dataframe

# Step 2: Calculate the VintageBalance row for each vintage and create new dataframes
for vintage, df_list in vintage_groups.items():
    # Collect all unique column names across dataframes for this vintage
    all_columns = set(col for _, df in df_list for col in df.columns)
    
    # Initialize an empty dictionary to store the VintageBalance values
    vintage_balance = {}
    
    # Sum current balances by column name across dataframes in the same vintage group
    for col_name in all_columns:
        # Sum the Current Balance for this column if it exists in each dataframe
        column_sum = sum(df.loc['Current Balance', col_name] for _, df in df_list if col_name in df.columns)
        
        # Store the summed balance in the vintage_balance dictionary
        vintage_balance[col_name] = column_sum

    # Convert the vintage_balance dictionary to a DataFrame row
    vintage_balance_series = pd.Series(vintage_balance, name='VintageBalance')

    # Step 3: Create new dataframes with the VintageBalance row added
    for key, df in df_list:
        # Copy the original dataframe to avoid modifying it
        modified_df = df.copy()
        
        # Align VintageBalance with existing columns, filling with NaN if columns are missing
        modified_df = pd.concat([modified_df, vintage_balance_series.reindex(modified_df.columns).to_frame().T])
        
        # Add the modified dataframe to the new dictionary without changing keys
        modified_df_dict[key] = modified_df

# Display the modified dataframes with VintageBalance
for key, df in modified_df_dict.items():
    print(f"\n{key}:\n{df}")
