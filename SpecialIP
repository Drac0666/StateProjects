import pandas as pd

def apply_conditions_mapping_specificity(
    DF: pd.DataFrame,
    conditions: pd.DataFrame,
    ConditionColumns: list,
    no_mapping_value: str = "NO MAPPING",
    tie_break: str = "first"  # "first" or "last"
) -> pd.DataFrame:
    # ---- 1) Validate ----
    missing_in_df = [c for c in ConditionColumns if c not in DF.columns]
    missing_in_cond = [c for c in ConditionColumns if c not in conditions.columns]
    if missing_in_df or missing_in_cond:
        raise SystemExit("Critical Error Condition Columns are missing")

    # ---- 2) Mapping columns = everything else in conditions ----
    mapping_cols = [c for c in conditions.columns if c not in ConditionColumns]

    # Ensure DF has mapping cols
    for c in mapping_cols:
        if c not in DF.columns:
            DF[c] = pd.NA

    def is_blank(x) -> bool:
        return pd.isna(x) or (isinstance(x, str) and x.strip() == "")

    def parse_allowed(cell):
        # blank -> wildcard (None)
        if is_blank(cell):
            return None
        parts = [p.strip() for p in str(cell).split("|")]
        parts = [p for p in parts if p != ""]
        return set(parts)

    # ---- 3) Precompile rules with a "specificity score" ----
    rules = []
    for idx, r in conditions.reset_index(drop=True).iterrows():
        allowed_by_col = {col: parse_allowed(r[col]) for col in ConditionColumns}
        specificity = sum(allowed_by_col[col] is not None for col in ConditionColumns)  # count non-wildcards
        mapping_values = {col: r[col] for col in mapping_cols}
        rules.append((idx, specificity, allowed_by_col, mapping_values))

    def rule_matches(df_row, allowed_by_col) -> bool:
        for col, allowed in allowed_by_col.items():
            if allowed is None:
                continue  # wildcard
            v = df_row[col]
            if is_blank(v):
                return False
            sv = str(v).strip()
            if sv not in allowed:
                return False
        return True

    # ---- 4) Apply: pick most specific matching rule ----
    def map_one_row(row):
        matches = []
        for idx, spec, allowed_by_col, mapping_values in rules:
            if rule_matches(row, allowed_by_col):
                matches.append((spec, idx, mapping_values))

        if not matches:
            for mc in mapping_cols:
                row[mc] = no_mapping_value
            return row

        # highest specificity wins
        max_spec = max(m[0] for m in matches)
        top = [m for m in matches if m[0] == max_spec]

        # tie-break by order in conditions
        if tie_break == "last":
            chosen = max(top, key=lambda x: x[1])  # largest idx
        else:
            chosen = min(top, key=lambda x: x[1])  # smallest idx

        mapping_values = chosen[2]
        for mc, mv in mapping_values.items():
            row[mc] = mv
        return row

    return DF.apply(map_one_row, axis=1)
