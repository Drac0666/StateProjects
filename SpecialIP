import pandas as pd
import numpy as np
from typing import Optional, Dict, Tuple

def issuer_limit_monitor_with_mt_addon(
    DF: pd.DataFrame,
    IssuerLimits: pd.DataFrame,
    MTDataframe: pd.DataFrame,
    exception_limits_mm: Optional[Dict[str, float]] = None,  # override IssuerLimit per MM_ISSUER
    exposure_col: str = "Exposure(USD)",
    issuer_col: str = "MM_ISSUER",
    mt_col: str = "MT_ISSUER",
    rating_col: str = "Lowest_Bucket_Rating",
    subasset_col: str = "Sub_Asset_Class",
    mt_lookup_col: str = "MT_ISSUER",
) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:
    """
    Always checks: Total exposure per MM_ISSUER vs IssuerLimit (rating-based; can be overridden by exception_limits_mm).
    Additional check: MT-only exposure (rows where MT_ISSUER is listed in MTDataframe) vs MasterTrustLimit.

    Returns:
      issuer_detail: per MM_ISSUER
      subasset_summary: Sub_Asset_Class | Count of Issuer | Max Exposure (+ extras)
      mt_summary: Sub_Asset_Class | Count of Issuer | Max MT Exposure (+ extras)  (MT-only view)
    """

    # ---- checks ----
    req_df = {issuer_col, mt_col, rating_col, subasset_col, exposure_col}
    req_lim = {rating_col, "IssuerLimit", "MasterTrustLimit"}
    req_mt = {mt_lookup_col}

    missing_df = req_df - set(DF.columns)
    missing_lim = req_lim - set(IssuerLimits.columns)
    missing_mt = req_mt - set(MTDataframe.columns)

    if missing_df:
        raise SystemExit(f"Critical Error: DF missing columns: {sorted(missing_df)}")
    if missing_lim:
        raise SystemExit(f"Critical Error: IssuerLimits missing columns: {sorted(missing_lim)}")
    if missing_mt:
        raise SystemExit(f"Critical Error: MTDataframe missing columns: {sorted(missing_mt)}")

    df = DF.copy()
    lim = IssuerLimits.copy()
    mt = MTDataframe.copy()

    # ---- normalize strings ----
    for c in [issuer_col, mt_col, rating_col, subasset_col]:
        df[c] = df[c].astype("string").str.strip()

    lim[rating_col] = lim[rating_col].astype("string").str.strip()
    mt[mt_lookup_col] = mt[mt_lookup_col].astype("string").str.strip()

    df[exposure_col] = pd.to_numeric(df[exposure_col], errors="coerce").fillna(0.0)
    lim["IssuerLimit"] = pd.to_numeric(lim["IssuerLimit"], errors="coerce")
    lim["MasterTrustLimit"] = pd.to_numeric(lim["MasterTrustLimit"], errors="coerce")

    mt_set = set(mt[mt_lookup_col].dropna().astype("string").str.strip().tolist())
    df["_is_mt_row"] = df[mt_col].isin(mt_set)

    # ---- issuer total exposure ----
    issuer_exposure = (
        df.groupby(issuer_col, dropna=False)[exposure_col].sum()
          .reset_index()
          .rename(columns={exposure_col: "IssuerExposure"})
    )

    # ---- MT-only exposure per issuer (only rows that are “MT bonds”) ----
    issuer_mt_exposure = (
        df[df["_is_mt_row"]]
        .groupby(issuer_col, dropna=False)[exposure_col].sum()
        .reset_index()
        .rename(columns={exposure_col: "MasterTrustExposure"})
    )

    # ---- Sub_Asset_Class per issuer: pick the one with max total exposure (stable grouping) ----
    issuer_subasset = (
        df.groupby([issuer_col, subasset_col], dropna=False)[exposure_col].sum()
          .reset_index()
          .sort_values([issuer_col, exposure_col], ascending=[True, False], kind="stable")
          .drop_duplicates(subset=[issuer_col])
          [[issuer_col, subasset_col]]
    )

    # ---- rating per issuer (first non-null); also flag inconsistencies ----
    issuer_rating = (
        df[[issuer_col, rating_col]]
        .dropna(subset=[rating_col])
        .drop_duplicates()
        .groupby(issuer_col, dropna=False)[rating_col]
        .agg(lambda s: s.iloc[0])
        .reset_index()
    )

    rating_counts = (
        df[[issuer_col, rating_col]]
        .dropna(subset=[rating_col])
        .drop_duplicates()
        .groupby(issuer_col)[rating_col].nunique()
        .reset_index(name="DistinctRatings")
    )

    # ---- build issuer_detail ----
    issuer_detail = (
        issuer_exposure
        .merge(issuer_mt_exposure, on=issuer_col, how="left")
        .merge(issuer_subasset, on=issuer_col, how="left")
        .merge(issuer_rating, on=issuer_col, how="left")
        .merge(lim[[rating_col, "IssuerLimit", "MasterTrustLimit"]], on=rating_col, how="left")
        .merge(rating_counts, on=issuer_col, how="left")
    )

    issuer_detail["MasterTrustExposure"] = issuer_detail["MasterTrustExposure"].fillna(0.0)
    issuer_detail["DistinctRatings"] = issuer_detail["DistinctRatings"].fillna(0).astype(int)

    # ---- exception limits for IssuerLimit (highest priority for issuer check) ----
    exception_limits_mm = exception_limits_mm or {}
    exc = pd.Series(exception_limits_mm, name="ExceptionIssuerLimit")
    exc.index.name = issuer_col
    exc = exc.reset_index()
    exc["ExceptionIssuerLimit"] = pd.to_numeric(exc["ExceptionIssuerLimit"], errors="coerce")

    issuer_detail = issuer_detail.merge(exc, on=issuer_col, how="left")

    issuer_detail["EffectiveIssuerLimit"] = issuer_detail["ExceptionIssuerLimit"].combine_first(issuer_detail["IssuerLimit"])

    # ---- utilization (Issuer) ----
    issuer_detail["IssuerUtilization"] = np.where(
        pd.to_numeric(issuer_detail["EffectiveIssuerLimit"], errors="coerce").fillna(0.0) > 0,
        issuer_detail["IssuerExposure"] / issuer_detail["EffectiveIssuerLimit"],
        np.nan
    )
    issuer_detail["IssuerBreach"] = np.where(issuer_detail["IssuerUtilization"] >= 1, 1, 0)

    # ---- utilization (MasterTrust add-on) ----
    issuer_detail["MasterTrustUtilization"] = np.where(
        pd.to_numeric(issuer_detail["MasterTrustLimit"], errors="coerce").fillna(0.0) > 0,
        issuer_detail["MasterTrustExposure"] / issuer_detail["MasterTrustLimit"],
        np.nan
    )
    issuer_detail["MasterTrustBreach"] = np.where(issuer_detail["MasterTrustUtilization"] >= 1, 1, 0)

    # ---- summary by Sub_Asset_Class (as requested) ----
    subasset_summary = (
        issuer_detail.groupby(subasset_col, dropna=False)
        .agg(
            **{
                "Count of Issuer": (issuer_col, "nunique"),
                "Max Exposure": ("IssuerExposure", "max"),
                # optional extras you may keep/drop
                "Issuer Breaches": ("IssuerBreach", "sum"),
                "Max Issuer Utilization": ("IssuerUtilization", "max"),
            }
        )
        .reset_index()
        .rename(columns={subasset_col: "Sub_Asset_Class"})
        .sort_values(["Max Issuer Utilization", "Max Exposure"], ascending=[False, False], kind="stable")
    )

    # ---- optional MT-only summary (sometimes very useful) ----
    mt_summary = (
        issuer_detail.groupby(subasset_col, dropna=False)
        .agg(
            **{
                "Count of Issuer": (issuer_col, "nunique"),
                "Max MT Exposure": ("MasterTrustExposure", "max"),
                "MT Breaches": ("MasterTrustBreach", "sum"),
                "Max MT Utilization": ("MasterTrustUtilization", "max"),
            }
        )
        .reset_index()
        .rename(columns={subasset_col: "Sub_Asset_Class"})
        .sort_values(["Max MT Utilization", "Max MT Exposure"], ascending=[False, False], kind="stable")
    )

    return issuer_detail, subasset_summary, mt_summary







exception_limits = {
    "ISSUER_ABC": 250_000_000,  # override IssuerLimit only (issuer check)
}

issuer_detail, subasset_summary, mt_summary = issuer_limit_monitor_with_mt_addon(
    DF=DF,
    IssuerLimits=IssuerLimits,
    MTDataframe=MTDataframe,
    exception_limits_mm=exception_limits
)

# Twoje wymagane wyjście:
print(subasset_summary[["Sub_Asset_Class", "Count of Issuer", "Max Exposure"]])
