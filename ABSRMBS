import pandas as pd

# Sample dictionary of dataframes with unique constant values in column 'A'
dataframes = {
    'df1': pd.DataFrame({'A': ['Test'], 'Value': [10]}),
    'df2': pd.DataFrame({'A': ['Kurwa'], 'Value': [20]}),
    'df3': pd.DataFrame({'A': ['Test'], 'Value': [30]})
}

# Create a dictionary to categorize dataframes
categorized_dataframes = {}

# Specify the column to use for categorization
categorize_by_column = 'A'

# Iterate through dataframes and categorize
for df_name, df in dataframes.items():
    category = df[categorize_by_column].iloc[0]
    category_lower = category.lower()  # Convert category to lowercase
    if category_lower not in categorized_dataframes:
        categorized_dataframes[category_lower] = {}
    categorized_dataframes[category_lower][df_name] = df

# Print categorized dataframes
for category, df_dict in categorized_dataframes.items():
    print(f'Category: {category}')
    for df_name, df in df_dict.items():
        print(f'{df_name}:\n{df}\n')





# Sample dictionary with keys containing "-Cstats" suffix
my_dict = {
    'key1-Cstats': 10,
    'key2-Cstats': 20,
    'key3-Cstats': 30
}

# Remove the "-Cstats" suffix from keys
updated_dict = {key.replace('-Cstats', ''): value for key, value in my_dict.items()}

print(updated_dict)



import pandas as pd

def find_first_keys_in_second_dict(my_dict, **key_lists):
    results = {}
    for identifier, value_list in my_dict.items():
        second_dict = value_list[1] if len(value_list) > 1 else {}
        for key_list_name, keys in key_lists.items():
            for key in keys:
                if key in second_dict:
                    if identifier in results:
                        results[identifier][key_list_name] = second_dict[key]
                    else:
                        results[identifier] = {key_list_name: second_dict[key]}
                    break  # Stop searching in this list of keys if a match is found
    return results

# Example usage:
my_dict = {
    "ID1": [{}, {"cherry": 2, "apple": 3}],
    "ID2": [{}, {"banana": 5, "date": 1}],
    "ID3": [{}, {"mango": 8, "lemon": 6}],
}

keys_list1 = ["cherry", "grape", "apple"]
keys_list2 = ["banana", "kiwi", "date"]
keys_list3 = ["mango", "lemon", "apple"]

results = find_first_keys_in_second_dict(my_dict, key_list1=keys_list1, key_list2=keys_list2, key_list3=keys_list3)

if results:
    df = pd.DataFrame(results).T.fillna('Not Found')
    print(df)
else:
    print("None of the keys were found in the dictionaries.")



/////////////###################



# Sample dictionary with multiple keys
data_dict = {
    'DATE_MM': '2023-11-01|2023-11-02|2023-11-03|2023-11-04|2023-11-05|2023-11-06|2023-11-07|2023-11-08|2023-11-09|2023-11-10',
    'CPR': 'CPR1|CPR2||CPR4|NA||||CPR8||',
    'CDR': 'CDR1||CDR3|CDR4|CDR5|||||CDR9|CDR10',
    'Severity': 'Low|Medium|High|Low|Medium|||||High|Low'
}

def process_keys_to_mapping(data, keys):
    mapping = {}
    dates = data['DATE_MM'].split('|')
    for date in dates:
        values = {}
        for key in keys:
            key_values = data[key].split('|')
            value = key_values[dates.index(date)]
            if value and value != "NA":
                values[key] = value
        if values:
            mapping[date] = values
    return mapping

keys_to_process = ['CPR', 'CDR', 'Severity']
date_values_mapping = process_keys_to_mapping(data_dict, keys_to_process)

# Printing the resulting mapping
for date, values in date_values_mapping.items():
    print(f"Date: {date}, Values: {values}")













# Sample dictionary
data_dict = {
    'DATE_MM': '2023-11-01|2023-11-02|2023-11-03|2023-11-04|2023-11-05|2023-11-06|2023-11-07|2023-11-08|2023-11-09|2023-11-10',
    'CPR': 'CPR1|CPR2||CPR4|NA||||CPR8||'
}

# Split the values by '|' to get lists of dates and CPR values
date_mm_values = data_dict['DATE_MM'].split('|')
cpr_values = data_dict['CPR'].split('|')

# Create a mapping between dates and CPR values, skipping empty and "NA" values
date_cpr_mapping = {}
for date, cpr in zip(date_mm_values, cpr_values):
    if cpr and cpr != "NA":
        date_cpr_mapping[date] = cpr

# Example: Get CPR value for a specific date
desired_date = '2023-11-04'
if desired_date in date_cpr_mapping:
    cpr_value = date_cpr_mapping[desired_date]
    print(f"For date {desired_date}, the CPR value is {cpr_value}")
else:
    print(f"No CPR value found for date {desired_date}")




counts_df.index = counts_df.index.astype(str).str.replace(r'[\[\]()]', '').str.replace(', ', '-').str.split(',').str[0]
import pandas as pd
import numpy as np

# Sample data (replace this with your actual data)
data = {
    'column1': np.random.randint(1, 101, 100),  # Generating random data for column1
    'column2': np.random.randint(1, 101, 100)  # Generating random data for column2
}

df = pd.DataFrame(data)

# Combine data from both columns
combined_data = pd.concat([df['column1'], df['column2']])

# Specify the number of bins
num_bins = 10

# Calculate bin edges based on the combined data
min_val = combined_data.min()
max_val = combined_data.max()
bin_width = (max_val - min_val) / num_bins
bin_edges = [min_val + i * bin_width for i in range(num_bins + 1)]

# Apply pd.cut to both columns using the same bin edges
df['bin_range_column1'] = pd.cut(df['column1'], bins=bin_edges)
df['bin_range_column2'] = pd.cut(df['column2'], bins=bin_edges)

# Display the DataFrame with assigned ranges for both columns
print(df)

count_column1 = df['bin_range_column1'].value_counts()
count_column2 = df['bin_range_column2'].value_counts()
counts_df = pd.DataFrame({'Count_Column1': count_column1, 'Count_Column2': count_column2}).fillna(0)
